#'Perform Sample Pre-processing
#'
#'@description Sample pre-processing so that the data is ready for analysis
#'@param RGset The RGset generated by the function loadingSamples. If you want
#'  to adjust for batch effects using ComBat, the pData of the RGset must
#'  include the column 'Batch'
#'@param SamplestoRemove An optional character vector of Basenames to exclude
#'  based on the exploratory data analysis; default is NULL
#'@param ProbestoRemove An optional character vector of CpGIDs to exclude based
#'  on the exploratory data analysis; default is NULL
#'@param DetectionPvals An optional matrix where DNA methylation intensities are
#'  coded as NA (missing) if they do not meet the detection p-value, and 1
#'  otherwise. This matrix is returned by the function ExploratoryDataAnalysis
#'@param compositeCellType A required character string indicating the type of
#'  cell composition estimation to perform. The default is "RefFree" indicating
#'  a reference-free deconvolution; other options are "Blood", "Placenta", and
#'  "CordBlood" to be used with the Houseman reference-based approach. The
#'  placenta reference-based approach is based on the data curated in the
#'  following publication: https://www.researchsquare.com/article/rs-38223/v3
#'@param KchooseManual Optional numeric value (e.g 2) used to manually set the K
#'  (number of cell types) estimated using RefFreeCellMixArray. May need to do
#'  this if it seems that there is an extreme outlier driving the number of cell
#'  types estimated. See details for more information; the default value is NULL
#'@param destinationfolder A character string indicating the location where
#'  files should be saved, e.g. "C:\\Home\\PACE\\BirthSize"
#'@param savelog logic; TRUE indicates to save a log of the functions run
#'  (default)
#'@param cohort A character string for the cohort's acronym (e.g. "HEBC")
#'@param analysisdate A character string indicating the date the analysis was
#'  run. Please specify in the form: YEARMONTHDAY, e.g. "20200205" for February
#'  5th 2020
#'@details  Pre-processing steps include: \enumerate{ \item Drop samples and CpG
#'  loci based on exploratory data analysis \item Dye-bias correction by linear
#'  scaling based on normalization control probes on both color channels (minfi
#'  approach), followed by Noob (normal-exponential using out-of-band probes)
#'  background correction. \item Functional normalization \item Beta-mixture
#'  quantile (BMIQ) normalization method to correct for the bias of type-2 probe
#'  values \item Correction for batch effects (if indicated) using ComBat \item
#'  Estimate cellular heterogeneity with the RefFree method (Houseman et al) or
#'  reference-based approaches. After estimating RefFree Omega, examine
#'  OutlierScreening plots generated by this function to ensure no extreme
#'  outliers are being generated. If so, reduce Kchoose value by 1 using the
#'  argument KchooseManual, re-run the function preprocessingofData, and
#'  re-examine outlier plots. Reduce KchooseManual until extreme outliers are
#'  gone. \item Remove extreme outliers using a modified version of GapHunter.
#'  Gaps must be at least 3*IQR; the cutoff for the number of outliers in a
#'  group is either a maximum of 5 or 0.0025 of the total number of samples
#'  (whichever is larger). Detected outliers are recoded as NA.}
#'@return Figures (PDFs/PNGs) of associations between top PCs and indicators of
#'  batch before and after ComBat (if an indicator for batch was included in the
#'  dataset), as well as plots to identify potential outliers driving the
#'  estimated cell composition estimates. Also saves an RData file and returns a
#'  list that includes: \item{mset}{A GenomicRatioSet subset to the samples and
#'  CpG loci among the matrix of processed beta-values}
#'  \item{processedBetas}{Matrix of the processed beta-values} \item{Kchoose}{A
#'  numeric value indicating the number of cell types selected by the RefFree
#'  method}\item{Omega}{A matrix of cell composition estimates generated by the
#'  RefFree method}
#'@examples
#'\dontrun{
#'processedOut<-preprocessingofData(RGset=exampledat,
#'                                  SamplestoRemove=EDAtrying$SamplestoRemove,
#'                                  ProbestoRemove=EDAtrying$ProbestoRemove,
#'                                  DetectionPvals=EDAtrying$DetectionPvals,
#'                                  compositeCellType ="RefFree",
#'                                  KchooseManual=NULL,
#'                                  destinationfolder="H:/UCLA/PACE/Birthweight-placenta",
#'                                  savelog=TRUE,
#'                                  cohort="HEBC",analysisdate="20200710")
#'}

preprocessingofData<-function(RGset=RGset,SamplestoRemove=NULL,ProbestoRemove=NULL,
                              DetectionPvals=NULL,
                              compositeCellType="RefFree",
                              KchooseManual=NULL,
                              cohort=cohort,analysisdate=analysisdate,destinationfolder=NULL,savelog=TRUE){

  if(is.null(destinationfolder)) stop("Please specify a destination folder")

  Outputname<-paste(cohort,"_",analysisdate,"_Output",sep="")
  dir.create(file.path(destinationfolder, Outputname), showWarnings = FALSE)
  destinationfolder<-paste(destinationfolder,Outputname,sep="/")
  setwd(destinationfolder)

  if(!('Batch' %in% colnames(pData(RGset)))) cat("'Batch' variable not included in RGset pData, will not run ComBat")

  if(savelog){

    sink()
    sink(type="message")

    con <- file("log_step3.log")
    sink(con, append=TRUE)
    sink(con, append=TRUE, type="message")
  }

  Kchoose<-NA # starting values
  Omega<-NA # starting values

  ## removing any poorly performing IDs based on exploratory data analysis
  if (!is.null(SamplestoRemove) & length(SamplestoRemove)>0){
    cat("Removing",length(SamplestoRemove),"samples...","\n")
    RGset<-RGset[,!(sampleNames(RGset) %in% SamplestoRemove)]
  } else {
    cat("Removing zero samples...","\n")
  }

  cat("Running Functional Normalization...","\n")
  ## Rerunning functional normalization
  Mset.norm = preprocessFunnorm(RGset, sex = NULL, bgCorr = T, dyeCorr = T, nPCs = 2, verbose = TRUE)

  ## removing any poorly performing probes based on exploratory data analysis
  if (!is.null(ProbestoRemove) & length(ProbestoRemove)>0){
    cat("Removing",length(ProbestoRemove),"probes...","\n")
    Mset.norm<-Mset.norm[!(featureNames(Mset.norm) %in% ProbestoRemove),]
  } else {
    cat("Removing zero probes...","\n")
  }

  justbetas.norm<-getBeta(Mset.norm)

  ## Run BMIQ function:
  ProbeType = as.character(getAnnotation(Mset.norm)$Type)
  ProbeType = ifelse(ProbeType %in% "I",1,2)
  FunNorm.BMIQ<-apply(justbetas.norm,2,function(x) wateRmelon::BMIQ(x,ProbeType,nfit=10000,plots=FALSE)$nbeta)

  annotdat<-as.data.frame(getAnnotation(Mset.norm))
  annotdat$chr<-as.character(annotdat$chr)
  annotdat_XY<-annotdat[which(annotdat$chr=="chrX" | annotdat$chr=="chrY"),]

  ### PREPARING FOR COMBAT

  ## Calculate the variance of each probe and remove any with a variance of 0 prior to Combat
  mval <- apply(FunNorm.BMIQ, 2, function(x) log2((x)/(1-x)))
  vars = as.matrix(rowVars(mval))

  ## Replace all probes with no variance with NA and remove them from the FunNorm set
  vars[vars == 0] = NA
  vars = na.omit(vars)
  intersect = intersect(rownames(vars), rownames(mval))
  cat(nrow(mval) - length(intersect), "probes had no variance and were removed","\n")
  fn.sub = FunNorm.BMIQ[intersect,]
  mval = mval[intersect,]

  ## Run a principle component analysis to determine if there are any remaining
  ## batch effects following data normalization.

  ## removing chr X and Y
  mval_pca<-mval[!(rownames(mval) %in% rownames(annotdat_XY)),]
  pcadataall<-prcomp(t(na.omit(mval_pca)), retx = T, center = T, scale. = T)
  tempimportance<-summary(pcadataall)$importance
  pcadata<-as.data.frame(pcadataall$x)
  maxPCs<-min(c(12,ncol(pcadata)))
  pcadata<-pcadata[,paste("PC",1:maxPCs,sep="")]
  pcadata$ID<-pData(Mset.norm)$ID

  if("Batch" %in% colnames(pData(RGset))){

    temppcadata<-pcadata
    temppcadata$Batch<-pData(Mset.norm)$Batch
    temppcadata_v1<-temppcadata
    temppcadata<-reshape::melt(temppcadata,id=c("ID","Batch"))
    temppcadata$NumPClab<-as.numeric(sub("PC","",as.character(temppcadata$variable)))
    labelinfo<-plyr::ddply(temppcadata,.(variable),function(x) paste("p=",format(round(summary(aov(value~as.factor(Batch),data=x))[[1]]["as.factor(Batch)","Pr(>F)"],3),nsmall=3),sep=""))
    labelinfo$PropofVar<-paste("% of Var=",format(round(tempimportance[2,1:maxPCs]*100,2),nsmall=2),sep="")
    temppcadata<-merge(temppcadata,labelinfo,by="variable")
    temppcadata$label<-paste(temppcadata$variable,"\n",temppcadata$PropofVar,"\n",temppcadata$V1,sep="")
    temppcadata<-temppcadata[order(temppcadata$NumPClab),]
    temppcadata$label<-as.factor(temppcadata$label)
    temppcadata$label<-factor(temppcadata$label,levels=unique(temppcadata$label))

    p<-ggplot(temppcadata,aes(as.factor(Batch),value))+
      geom_boxplot(outlier.shape=NA)+
      geom_jitter()+
      facet_wrap(~label,ncol=3,scales="free_y")+
      theme_bw()+
      xlab("Batch Indicator")+
      theme(axis.title=element_text(face="bold",size=14))

    ggsave(filename=paste(cohort,"_",analysisdate,"_Association_between_Batch_and_Top_PCs_Before_ComBat.png",sep=""),
           plot=p,width=10,height=10,units="in")

  }

  ## removing batch effects
  if("Batch" %in% colnames(pData(Mset.norm))){
    cat("Using ComBat to remove batch effects...","\n")
    modcombat <- model.matrix(~1, data=pData(Mset.norm))
    combat.adj <- sva::ComBat(dat=mval, batch=as.character(pData(Mset.norm)$Batch), mod=modcombat, par.prior=TRUE, prior.plots=FALSE)
  } else {
    cat("No batch effects specified...","\n")
    combat.adj <- mval
  }

  ## removing chr X and Y
  combat.adj_pca<-combat.adj[!(rownames(combat.adj) %in% rownames(annotdat_XY)),]

  pcadataall<-prcomp(t(na.omit(combat.adj_pca)), retx = T, center = T, scale. = T)
  tempimportance<-summary(pcadataall)$importance
  pcadata<-as.data.frame(pcadataall$x)
  maxPCs<-min(c(12,ncol(pcadata)))
  pcadata<-pcadata[,paste("PC",1:maxPCs,sep="")]
  pcadata$ID<-pData(Mset.norm)$ID

  if("Batch" %in% colnames(pData(RGset))){

    temppcadata<-pcadata
    temppcadata$Batch<-pData(Mset.norm)$Batch
    temppcadata_v2<-temppcadata
    temppcadata<-reshape::melt(temppcadata,id=c("ID","Batch"))
    temppcadata$NumPClab<-as.numeric(sub("PC","",as.character(temppcadata$variable)))
    labelinfo<-plyr::ddply(temppcadata,.(variable),function(x) paste("p=",format(round(summary(aov(value~as.factor(Batch),data=x))[[1]]["as.factor(Batch)","Pr(>F)"],3),nsmall=3),sep=""))
    labelinfo$PropofVar<-paste("% of Var=",format(round(tempimportance[2,1:maxPCs]*100,2),nsmall=2),sep="")
    temppcadata<-merge(temppcadata,labelinfo,by="variable")
    temppcadata$label<-paste(temppcadata$variable,"\n",temppcadata$PropofVar,"\n",temppcadata$V1,sep="")
    temppcadata<-temppcadata[order(temppcadata$NumPClab),]
    temppcadata$label<-as.factor(temppcadata$label)
    temppcadata$label<-factor(temppcadata$label,levels=unique(temppcadata$label))

    p<-ggplot(temppcadata,aes(as.factor(Batch),value))+
      geom_boxplot(outlier.shape=NA)+
      geom_jitter()+
      facet_wrap(~label,ncol=3,scales="free_y")+
      theme_bw()+
      xlab("Batch Indicator")+
      theme(axis.title=element_text(face="bold",size=14))


    ggsave(filename=paste(cohort,"_",analysisdate,"_Association_between_Batch_and_Top_PCs_After_ComBat.png",sep=""),
           plot=p,width=10,height=10,units="in")

  }

  ## removing batch effects
  if("Batch" %in% colnames(pData(Mset.norm))){
    #### Check whether batches are still distinguished by first and second PC:
    temppcadata_v1$BatchCorrection<-"Before ComBat"
    temppcadata_v2$BatchCorrection<-"After ComBat"
    beforeafter<-rbind(temppcadata_v1,temppcadata_v2)
    beforeafter$BatchCorrection<-as.factor(beforeafter$BatchCorrection)
    beforeafter$BatchCorrection<-factor(beforeafter$BatchCorrection,levels=c("Before ComBat","After ComBat"))
    p<-ggplot(beforeafter,aes(PC1,PC2,col=as.character(Batch)))+
      geom_point()+
      theme_bw()+
      scale_color_brewer("Batch",palette = "Set1")+
      facet_wrap(~BatchCorrection,nrow=1)

    ggsave(filename=paste(cohort,"_",analysisdate,"_Association_between_Batch_and_Top_PCs_Before_and_After_ComBat.png",sep=""),
           plot=p,width=10,height=5,units="in")

  }

  betafinal = expit2(combat.adj)

  ## Performs a quality mask and non-detection mask
  ## quality mask is based on this publication: https://academic.oup.com/nar/article/45/4/e22/2290930
  temparray<-Mset.norm@annotation["array"]
  if(temparray=="IlluminaHumanMethylation450k"){
    maskinfo<-sesameData::sesameDataGet("HM450.probeInfo")$mask
  }
  if(temparray=="IlluminaHumanMethylationEPIC"){
    maskinfo<-sesameData::sesameDataGet("EPIC.probeInfo")$mask
  }

  if(compositeCellType=="RefFree"){

    ## First reducing to high-quality probes
    betafinal_subset<-betafinal[!(rownames(betafinal) %in% maskinfo),]
    betafinal_subset<-betafinal_subset[!(rownames(betafinal_subset) %in% rownames(annotdat_XY)),]

    #################################################################################
    # Estimate K (number of cell types)

    ## Calculated variance for each CpG site, only using most variable 10,000 sites:
    v 			= apply(betafinal_subset,1,var,na.rm=TRUE)
    y.tops 		= betafinal_subset[names(v[order(v,decreasing=TRUE)][1:10000]),]

    cat("Estimating the optimal number of cell types (k)...","\n")
    # Get an array of solutions (for different values of K), using 50 iterations per solution:
    cellmixArray	= RefFreeEWAS::RefFreeCellMixArray(y.tops,Klist=1:12,iters=50)

    # If not specifying KchooseManual, must estimate K using bootstap approach
    if(is.null(KchooseManual)){

      cat("Bootstrapping procedure to choose k...","\n")
      # Do the bootstrap procedure (Houseman Supplemental S3)

      cellmixArrayBoot	<- try(
        RefFreeEWAS::RefFreeCellMixArrayDevianceBoots(
          cellmixArray,            # Array object
          Y=y.tops,                # Data on which array was based
          R=100,                   # Number of bootstraps
          bootstrapIterations=10)  # Number of iterations per boot
        ,silent=TRUE)

      if(class(cellmixArrayBoot) == "try-error"){

        cat("Bootstrap step failed, going to assume k=2","\n")
        Kchoose 		= 2

      } else {

        # Show winsorized mean deviance per K
        wnsrMeanDev		= apply(cellmixArrayBoot[-1,], 2, mean, trim=0.25)

        # Choose K based on minimum deviance
        Kchoose 		= which.min(wnsrMeanDev)
        cat("Number of K chosen based on minimum deviance: ",Kchoose,"\n")

      }

      # If  specifying KchooseManual
    } else {

      Kchoose = KchooseManual

    }

    #################################################################################
    # Estimated cell-type proportions per sample (Omega) and methylation profiles of estimated cell-types (Mu)

    # PART A: Use above K with minimum deviance to generate estimated cell-mix (Omega)
    Omega 		= cellmixArray[[ Kchoose ]]$Omega # The cell mixture matrix

    if(class(Omega)=="matrix"){

      pdf(paste(cohort,"_",analysisdate,"_Omega_Heatmap.pdf",sep=""))
      heatmap(Omega)	# Visualize cell-mix across samples
      dev.off()

      tempframe<-as.data.frame(Omega)
      if(ncol(tempframe)==2){
        colnames(tempframe)<-c("Omega1","Omega2")
        pOmega<-ggplot(tempframe,aes(Omega1,Omega2))+geom_point()+theme_bw()

      } else {
        pOmega<-GGally::ggpairs(tempframe)+theme_bw()
      }
      ggsave(filename=paste(cohort,"_",analysisdate,"_Omega_OutlierScreening.pdf",sep=""),
             plot=pOmega,width=10,height=10,units="in")

      ### If omega is not a matrix, it is a numeric vector because there was only one K
    } else {

      tempframe<-data.frame(Omega1=Omega)
      ggplot(tempframe,aes(Omega1))+
        geom_histogram(col="darkgray",fill="lightgray")+
        theme_bw()
      dev.off()

    }

    #### !!!! Examine OutlierScreening plots, if obvious extreme outliers are generated in these plots, repeate Step 2, Part A, by
    #### !!!! Replacing 	Omega = cellmixArray[[ Kchoose ]]$Omega 		with 		Omega = cellmixArray[[ (Kchoose-1) ]]$Omega
    #### !!!! Can repeat this process (Kchoose-2), (Kchoose-3), etc. until no more outliers are being generated
    #### !!!! Once Omega doesn't contain extreme outliers, proceed with Part B

    # Part B: Mu for entire CpG array (contribution of individual CpGs to the cell-mixture estimation) for the entire array:
    Mu = RefFreeEWAS::RefFreeCellMix(
      Y=y.tops,  					# Data on which the solution was based
      mu0=cellmixArray[[ Kchoose ]]$Mu, 	# Mu from the solution
      Yfinal=betafinal,      		# The whole array
      iters=1)$Mu  				# One iteration is enough here
    dim(Mu)

    # Row variances to identify the most highly variable CpGs by Cell-Mix:
    Mu.Row.Var 			= as.data.frame(as.matrix(apply(Mu,1,var,na.rm=TRUE)))
    Mu.Row.Var$MVar		= as.numeric(as.factor(cut2(Mu.Row.Var[,1],g=20,levels.mean=TRUE)))
    Mu.Row.Var			= Mu.Row.Var[order(Mu.Row.Var[,1]*(-1)),]
    colnames(Mu.Row.Var) 	= c("Var","RankVar")

    write.csv(Mu.Row.Var, paste(cohort,"_",analysisdate,"_Variability_By_CellMix_CpGs.csv",sep=""), na="NA")

    # Remove 1 cell-type to reduce multi-colinearity
    if(Kchoose>1){
      Omega = Omega[ ,1:(length(colnames(Omega))-1)]
    }

  }

  if(compositeCellType=="Placenta"){

    MsetRaw<-preprocessRaw(RGset)

    pData(placentamethylsetT3)$CellCompareGroup<-"Reference"
    pData(MsetRaw)$CellCompareGroup<-"Input"

    combinedMset <- combineArrays(placentamethylsetT3, MsetRaw, outType = "IlluminaHumanMethylationEPIC")

    combinedMset<-preprocessQuantile(combinedMset)
    inputprocessedMset<-combinedMset[,which(pData(combinedMset)$CellCompareGroup=="Input")]
    inputprocessedbetas<-getBeta(inputprocessedMset)

    sharedCpGs<-intersect(rownames(plCellCpGsThird),rownames(inputprocessedbetas))
    placentabetas<-inputprocessedbetas[sharedCpGs,]
    plCellCpGsThird<-plCellCpGsThird[sharedCpGs,]

    ## Project cell composition using the constrained Houseman method
    Omega <- EpiDISH::epidish(
      beta.m = placentabetas,
      ref.m = plCellCpGsThird,
      method = "CP"
    )$estF

  }

  if(compositeCellType=="Blood"){

    ## IDOL set depends on the array used
    currentarray<-annotation(RGset)["array"]

    ## If using the EPIC array
    if(currentarray=="IlluminaHumanMethylationEPIC"){

      countsEPIC<-FlowSorted.Blood.EPIC::estimateCellCounts2(RGset, compositeCellType = "Blood",
                                                             processMethod = "preprocessNoob",
                                                             probeSelect = "IDOL",
                                                             cellTypes = c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Neu"),
                                                             referencePlatform ="IlluminaHumanMethylationEPIC",
                                                             referenceset = NULL,
                                                             IDOLOptimizedCpGs =IDOLOptimizedCpGs,
                                                             returnAll = FALSE)

      Omega<-countsEPIC$counts

    }

    ## If using the 450k array
    if(currentarray=="IlluminaHumanMethylation450k"){

      counts450K<-FlowSorted.Blood.EPIC::estimateCellCounts2(RGset, compositeCellType = "Blood",
                                                             processMethod = "preprocessNoob",
                                                             probeSelect = "IDOL",
                                                             cellTypes = c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Neu"),
                                                             referencePlatform ="IlluminaHumanMethylationEPIC",
                                                             referenceset = NULL,
                                                             IDOLOptimizedCpGs =IDOLOptimizedCpGs450klegacy,
                                                             returnAll = FALSE)

      Omega<-counts450K$counts

    }


  }

  if(compositeCellType=="CordBlood"){

    countsCBC<-FlowSorted.Blood.EPIC::estimateCellCounts2(RGset,
                                   compositeCellType = "CordBloodCombined",
                                   processMethod = "preprocessNoob",
                                   probeSelect = "IDOL",
                                   cellTypes = c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran", "nRBC"),
                                   referencePlatform = "IlluminaHumanMethylation450k",
                                   referenceset = "FlowSorted.CordBloodCombined.450k",
                                   IDOLOptimizedCpGs = IDOLOptimizedCpGsCordBlood,
                                   returnAll = FALSE)

    Omega<-countsCBC$counts

  }


  #################################################################################
  # R-code for detecting outliers using gaphunter

  cat("Detecting beta-value outliers...","\n")
  # Required input & parameters
  N <- ncol(betafinal) ## No. of samples in your data.
  cutoff <- ifelse(0.0025*N<5,5,ceiling(N*0.0025))
  ## This cutoff is chosen for detecting probes with outliers. We have chosen this
  ## cutoff such that a probe can have a maximum of 5 or 0.0025 of the total number
  ## of samples (whichever is larger) as outliers. Can change it if required.

  betafinal.nooutlier<-newgapfinder(betamatrix = betafinal,cutoffnum=cutoff)

  betafinal.nooutlier.CpGperc<-apply(betafinal.nooutlier,1,function(x) (sum(is.na(x))/ncol(betafinal.nooutlier))*100)
  betafinal.nooutlier.sampleperc<-apply(betafinal.nooutlier,2,function(x) (sum(is.na(x))/nrow(betafinal.nooutlier))*100)
  write.csv(betafinal.nooutlier.CpGperc,paste(cohort,"_",analysisdate,"_NewGapHunter_CpGs.csv",sep=""))
  write.csv(betafinal.nooutlier.sampleperc,paste(cohort,"_",analysisdate,"_NewGapHunter_Individuals.csv",sep=""))

  if(!is.null(DetectionPvals)){

    ## first restricting to the same probes and samples
    DetectionPvals<-DetectionPvals[rownames(betafinal.nooutlier),]
    DetectionPvals<-DetectionPvals[,colnames(betafinal.nooutlier)]

    betafinal.nooutlier<-betafinal.nooutlier*DetectionPvals
  }

  summarybetas<-apply(betafinal.nooutlier,1,function(x){
    tempx<-na.omit(x)
    Ntemp<-length(tempx)
    Nmisstemp<-length(x)-Ntemp
    Mintemp<-min(tempx)
    Maxtemp<-max(tempx)
    Mediantemp<-median(tempx)
    Meantemp<-mean(tempx)
    sdtemp<-sd(tempx)
    c(n=Ntemp,Nmissing=Nmisstemp,min=Mintemp,max=Maxtemp,median=Mediantemp,mean=Meantemp,sd=sdtemp)
  })

  summarybetas<-t(summarybetas)
  write.csv(summarybetas,paste(cohort,"_",analysisdate,"_Summarize_Beta_Values.csv",sep=""))

  processedOut<-list(mset=Mset.norm,processedBetas=betafinal.nooutlier,Omega=Omega,Kchoose=Kchoose)
  save(file=paste(cohort,"_",analysisdate,"_Preprocessed.RData",sep=""),compress=TRUE, list=c("processedOut"))

  if(savelog){
    sink()
    sink(type="message")
  }

  return(processedOut)

}
